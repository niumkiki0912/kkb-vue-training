###  

##### 问题

- 你了解哪些vue性能优化方法？

##### 回答

- 代码层面的优化

  - **v-if 和v-show区分使用场景**

    - v-show会预渲染dom，所以除需要预先渲染或者频繁切换显示效果，都尽量使用v-if
    - v-if是真正的条件渲染，它会确保在切换过程中条件块内的事件监听器和子组件适当地被销毁和重建。v-if是惰性的：如果在初始渲染时条件为假，则什么也不做，直到条件第一次变为真时，才会开始渲染条件块

  - **computed 和 watch 区分使用场景**

    - computed : 计算属性，依赖其它属性值，并且computed的值有缓存，只有它依赖的属性值发生改变，下一次获取computed 的值时才会重新计算computed 的值
    - watch 当我们需要在数据变化时执行异步或开销较大的操作时使用

  - **v-for 遍历必须为item添加key, 且避免使用v-if**

    - key：唯一标识，辅助判断新旧虚拟dom节点的状态值对比，较快的定位到diff
    - v-for  比 v-if 优先级高，如果每一次都需要遍历整个数组，将会影响速度，尤其是当只需要渲染很小一部分的时候，必要情况下应该替换成 computed 属性。

  - **事件销毁**

    - 如果在js 内部使用addEventListener等方式时，vue组件销毁时时不会自动销毁这些的，我们需要在组件销毁时手动移除这些事件的监听

  - **路由懒加载**

    - vue是单页面应用，可能会有很多的路由引入，这样使webpack打包后文件很大，这也会使进入首页时页面白屏，不利于用户体验

    - 把不同路由对应的组件分割成不同的代码块，然后当路由被访问到时才加载对应组件，会大大提高首屏显示速度

    - ```javascript
      const Foo = () => import('./Foo.vue')
      const router = new  VueRouter({
        routes: [
          {path: '/foo', component: Foo}
        ]
      })
      ```

  - **图片资源懒加载**

  - **服务端渲染SSR**

- webpack层面的优化

  - **webpack 对图片进行压缩**

    - 可以在配置文件中url-loader中设置limit大小来对图片进行处理，对小于limit的图片转化为base64
    - 对有些较大 的图片资源，可以使用`image-webpack-loader`来压缩图片

  - **提取公共代码**

    - 如果项目中没有将每个页面的第三方库和公共模块提取出来，会造成相同资源被重复加载，首屏加载速度慢，浪费性能，影响用户体验。所以需要将公共代码抽离成单独文件。

    - webpack内置插件CommonsChunkPlugin可以用于抽离

      ​

  ​